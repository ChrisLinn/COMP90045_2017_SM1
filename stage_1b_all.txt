============================================
vis/zequnm.out
18:00:07_Sunday_09_April_2017
============================================
COMP90045 project - Test of parser and pretty-printer
User:  zequnm

--- Makefile found ---
--- Running Makefile ---
ocamlopt  -g -c snick_ast.ml
ocamlyacc snick_parse.mly
ocamlc  -c snick_parse.mli
ocamlopt  -g -c snick_parse.ml
ocamllex snick_lex.mll
94 states, 5679 transitions, table size 23280 bytes
ocamlopt  -g -c snick_lex.ml
ocamlopt  -g -c snick_pprint.ml
ocamlopt  -g -c snick.ml
File "snick.ml", line 56, characters 12-16:
Warning Y: unused variable prog.
ocamlopt -g -o snick snick_ast.cmx snick_lex.cmx snick_parse.cmx snick_pprint.cmx snick.cmx

--- Succeeded ---

**********************************************   Parsing bell.snick:
Mismatch:
1,29c1
< proc main ()
<     int n;
<     int result;
< 
<     write "Type integer n: ";
<     read n;
<     bell(n, 0, result);
<     write "Bell(n) is: ";
<     write result;
<     write "\n";
< end
< 
< proc bell (val int n, val int m, ref int out)
<     int res1;
<     int res2;
< 
<     if m = 0 then
<         if n = 0 then
<             out := 1;
<         else
<             bell(n - 1, n - 1, out);
<         fi
<     else
<         bell(n, m - 1, res1);
<         bell(n - 1, m - 1, res2);
<         out := res1 + res2;
<     fi
< end
< 
---
> proc
**********************************************   Parsing fib.snick:
Mismatch:
1,24c1
< proc main ()
<     int n;
<     int m;
< 
<     write ">";
<     read n;
<     fib(n, m);
<     write m;
<     write "\n";
< end
< 
< proc fib (val int n, ref int out)
<     int f1;
<     int f2;
< 
<     if n <= 1 then
<         out := n;
<     else
<         fib(n - 2, f1);
<         fib(n - 1, f2);
<         out := f1 + f2;
<     fi
< end
< 
---
> proc
**********************************************   Parsing gcd.snick:
Mismatch:
1,33c1
< proc main ()
<     int x;
<     int y;
<     int temp;
<     int quotient;
<     int remainder;
< 
<     write "Input two positive integers: ";
<     read x;
<     read y;
<     write "\n";
<     if x < y then
<         temp := x;
<         x := y;
<         y := temp;
<     fi
<     write "The gcd of ";
<     write x;
<     write " and ";
<     write y;
<     write " is ";
<     quotient := x / y;
<     remainder := x - quotient * y;
<     while remainder > 0 do
<         x := y;
<         y := remainder;
<         quotient := x / y;
<         remainder := x - quotient * y;
<     od
<     write y;
<     write "\n";
< end
< 
---
> proc
**********************************************   Parsing hail.snick:
Mismatch:
1,30c1
< proc main ()
<     int n;
<     int result;
< 
<     n := 1;
<     while n < 21 do
<         hail(n, result);
<         write result;
<         write " ";
<         n := n + 1;
<     od
<     write "\n";
< end
< 
< proc hail (val int in, ref int out)
<     int count;
< 
<     count := 1;
<     if in = 1 then
<         out := count;
<     else
<         if in / 2 * 2 = in then
<             hail(in / 2, count);
<         else
<             hail(3 * in + 1, count);
<         fi
<         out := count + 1;
<     fi
< end
< 
---
> proc
**********************************************   Parsing power.snick:
Mismatch:
1,30c1
< proc main ()
<     float x;
<     float result;
<     int n;
< 
<     write "Float x: ";
<     read x;
<     write "Positive integer n: ";
<     read n;
<     power(x, n, result);
<     write "x^n is: ";
<     write result;
<     write "\n";
< end
< 
< proc power (val float x, val int n, ref float out)
<     float res;
< 
<     if n = 1 then
<         out := x;
<     else
<         power(x * x, n / 2, res);
<         if 2 * (n / 2) = n then
<             out := res;
<         else
<             out := x * res;
<         fi
<     fi
< end
< 
---
> proc
**********************************************   Parsing sort.snick:
Mismatch:
1,38c1
< proc main ()
<     int h;
<     int j;
<     int k;
<     int tmp;
<     int x[1..8];
< 
<     write "Provide 8 integers: ";
<     read a[1];
<     read a[2];
<     read a[3];
<     read a[4];
<     read a[5];
<     read a[6];
<     read a[7];
<     read a[8];
<     h := 1;
<     while h < 8 do
<         j := h;
<         k := h + 1;
<         while k <= n do
<             if x[k] > x[j] then
<                 j := k;
<             fi
<         od
<         tmp := x[h];
<         x[h] := x[j];
<         x[j] := tmp;
<     od
<     write "\nThe integers, sorted:\n\n";
<     h := 1;
<     while h <= 8 do
<         write a[h];
<         write "  ";
<     od
<     write "\n";
< end
< 
---
> proc
**********************************************   Parsing stddev.snick:
Mismatch:
1,30c1
< proc main ()
<     float x;
<     float sum;
<     float sumsq;
<     float mean;
<     int count;
<     int done;
< 
<     write "Type a list of real numbers, ending with a negative number\n";
<     count := 0;
<     sum := 0.000000;
<     sumsq := 0.000000;
<     read x;
<     done := x < 0;
<     while not done do
<         count := count + 1;
<         sum := sum + x;
<         sumsq := sumsq + x * x;
<         read x;
<         done := x < 0;
<     od
<     mean := sum / count;
<     write "The mean is ";
<     write mean;
<     write "\n";
<     write "The variance is ";
<     write sumsq / count - mean * mean;
<     write "\n";
< end
< 
---
> proc
**********************************************   Parsing weird.snick:
Mismatch:
1,36c1
< proc q (val float x, ref int k)
<     int n;
<     float y;
<     bool a[1..8];
< 
<     a[8] := true;
<     k := 42;
< end
< 
< proc p (ref int i)
< 
<     i := 6 * i + 4;
< end
< 
< proc main ()
<     int m;
<     int n;
< 
<     read n;
<     while n > 1 do
<         m := n;
<         while m > 0 do
<             if m > 0 then
<                 n := n - 1;
<                 m := m - 1;
<                 if m = 0 then
<                     p(n);
<                 fi
<             else
<                 m := n - m;
<                 m := m - 1;
<             fi
<         od
<     od
< end
< 
---
> proc
**********************************************   Parsing paramsw.snick:
Okay
1 of 9 tests passed.

--- End of testing for zequnm ---\n

============================================
src/snick_parse.mly
18:00:06_Sunday_09_April_2017
============================================
/*
** File:          snick_ast.ml
** Description:   Specification of a parser for Snick
** Last Modified: Sun. 9th April 2017
** 
** Group name: Mainframe
** 
** Member names   | usernames
** Xianzhuo REN   | xianzhuor 
** Haoyu LIN      | haoyul3
** Zequn MA       | zequnm
*/

/* ocamlyacc parser for snick */
%{
open Snick_ast
%}

/* tokens */
%token EOF
%token PROC END
%token SEMICOLON
%token COMMA
%token DOT
%token WHILE DO OD
%token IF THEN ELSE FI
%token <bool> BOOL_CONST
%token <int> INT_CONST
%token <float> FLOAT_CONST
%token <string> STRING_CONST
%token VAL REF
%token <string> IDENT
%token BOOL INT FLOAT
%token WRITE READ
%token ASSIGN
%token OR
%token AND
%token NOT
%token EQ NE LT LE GT GE
%token PLUS MINUS
%token MULTI DIVID
%token LSQBRACK RSQBRACK
%token LPAREN RPAREN

/* associativity */
%nonassoc EQ NE LT GT LE GE
%left PLUS MINUS
%left MULTI DIVID
%left AND OR
%nonassoc NOT
%nonassoc UMINUS

%type <Snick_ast.program> program

%start program
%%

program:
    procs   { List.rev $1 }

/* Builds procs in reverse order */
procs:
    | procs proc { $2 :: $1 }
    | proc { [$1] }

proc:
    PROC proc_header proc_body END { ($2, $3) }

proc_header:
    IDENT LPAREN params RPAREN { ($1, List.rev $3) }

/* Builds params in reverse order */
params:
    | params COMMA param { $3 :: $1 }
    | param { [$1] }
    | { [] }

param:
    param_indc typespec IDENT { ($1, $2, $3) }

param_indc:
    | VAL { Val }
    | REF { Ref }

typespec:
    | BOOL { Bool }
    | FLOAT { Float }
    | INT { Int }

proc_body:
    decls stmts { { decls = List.rev $1; stmts = List.rev $2 } }

/* Builds decls in reverse order */
decls :
    | decls decl { $2 :: $1 }
    | { [] }  

decl:
    | typespec variable SEMICOLON { ($1, $2) }

variable:
    | IDENT { Single_variable $1 }
    | IDENT dimension { Array_variable ($1, $2) }

dimension:
    LSQBRACK intervals RSQBRACK { List.rev $2 }
  
/* Builds intervals in reverse order */
intervals:
    | intervals COMMA interval { $3 :: $1 }
    | interval { [$1] }

interval:
    INT_CONST DOT DOT INT_CONST { ($1, $4) }

/* Builds stmts in reverse order */
stmts:
    | stmts stmt { $2 :: $1 }
    | stmt { [$1] }

stmt:
    | atom_stmt { Atom_stmt $1 }
    | comps_stmt { Comps_stmt $1 }

atom_stmt:
    | elem ASSIGN expr SEMICOLON { Assign ($1, $3) }
    | READ elem SEMICOLON { Read $2 }
    | WRITE expr SEMICOLON { Write $2 }
    | IDENT LPAREN exprs_emptiable RPAREN SEMICOLON { Call ($1, List.rev $3) }

comps_stmt:
    | IF expr THEN stmts FI { If_then ($2, List.rev $4) }
    | IF expr THEN stmts ELSE stmts FI { If_then_else ($2, List.rev $4, List.rev $6) }
    | WHILE expr DO stmts OD { While ($2, List.rev $4) }

elem:
    | IDENT { Single_elem $1 }
    | IDENT LSQBRACK exprs RSQBRACK { Array_elem ($1, List.rev $3) }

expr:
    /* Variable element */
    | elem { Eelem $1 }
    /* Constants */
    | BOOL_CONST { Ebool $1 }
    | INT_CONST { Eint $1 }
    | FLOAT_CONST { Efloat $1 }
    | STRING_CONST { Estring $1 }
    /* Expression inside a pair of  parentheses */
    | LPAREN expr RPAREN { Eparen $2 }
    /* Binary operators */
    | expr PLUS expr { Ebinop ($1, Op_add, $3) }
    | expr MINUS expr { Ebinop ($1, Op_sub, $3) }
    | expr MULTI expr { Ebinop ($1, Op_mul, $3) }
    | expr DIVID expr { Ebinop ($1, Op_div, $3) }
    | expr EQ expr { Ebinop ($1, Op_eq, $3) }
    | expr NE expr { Ebinop ($1, Op_ne, $3) }
    | expr LT expr { Ebinop ($1, Op_lt, $3) }
    | expr GT expr { Ebinop ($1, Op_gt, $3) }
    | expr LE expr { Ebinop ($1, Op_le, $3) }
    | expr GE expr { Ebinop ($1, Op_ge, $3) }
    | expr AND expr { Ebinop ($1, Op_and, $3) }
    | expr OR expr { Ebinop ($1, Op_or, $3) }
    /* Unary operators */
    | NOT expr { Eunop (Op_not, $2) }
    | UMINUS expr %prec UMINUS { Eunop (Op_minus, $2) }


/* Builds exprs in reverse order */
exprs:
    | exprs COMMA expr { $3 :: $1 }
    | expr { [$1] }

exprs_emptiable:
    | exprs COMMA expr { $3 :: $1 }
    | expr { [$1] }
    | { [] }============================================
src/Makefile
18:00:05_Sunday_09_April_2017
============================================
#
# Makefile
#
# Group Name: Mainframe
#

TARGETS = snick
TARGETS_BYTE=$(TARGETS:%=%.byte)

MODULES = snick_ast snick_lex snick_parse snick_pprint
MLFILES = $(addsuffix .ml, $(MODULES))
CMOFILES = $(addsuffix .cmo, $(MODULES))
CMXFILES = $(addsuffix .cmx, $(MODULES))

ALLMODULES = $(MODULES) snick

OCAMLLEX = ocamllex
OCAMLYACC = ocamlyacc
OCAMLDEP = ocamldep

OCAMLFLAGS =

all : opt byte
byte: $(TARGETS_BYTE)
opt: $(TARGETS)

%.cmi: %.mli
	ocamlc $(OCAMLFLAGS) -c $<

%.cmo: %.ml
	ocamlc $(OCAMLFLAGS) -g -c $<

%.cmx: %.ml
	ocamlopt $(OCAMLOPTFLAGS) -g -c $<

%.ml: %.mll
	$(OCAMLLEX) $^

%.ml %.mli: %.mly
	$(OCAMLYACC) $^

snick.byte : $(CMOFILES) snick.cmo
	ocamlc -g -o $@ $^

snick : $(CMXFILES) snick.cmx
	ocamlopt -g -o $@ $^

clean :
	rm -f *.cmo *.cmi *.cmx *.o
	rm -f snick_lex.ml snick_parse.ml snick_parse.mli

clobber : clean
	rm -f $(TARGETS) $(TARGETS_BYTE)

.PHONY : clean clobber depend

# include depend
depend: snick_lex.ml snick_parse.ml
	$(OCAMLDEP) snick.ml snick.mli $(ALLMODULES:%=%.mli) $(ALLMODULES:%=%.ml) >Makefile.depend

-include Makefile.depend
============================================
src/snick_lex.mll
18:00:06_Sunday_09_April_2017
============================================
(*
** File:          snick_ast.ml
** Description:   Specification of a lexer for Snick
** Last Modified: Tue. 4th April 2017
** 
** Group name: Mainframe
** 
** Member names   | usernames
** Xianzhuo REN   | xianzhuor 
** Haoyu LIN      | haoyul3
** Zequn MA       | zequnm
*)

{
open Snick_parse
}

(* some regex patterns *)
let digit = ['0' - '9']
let digits = digit+
let floating = digits '.' digits
let alpha = ['a' - 'z' 'A' - 'Z']
let alnum = alpha | '_' | '\'' | digit
let ident = (alpha | '_') alnum*
let commment = '#' [^'\n']*     (* comments *)
let string = '"' [^'"']* '"'    (* string constant for write statement *)

rule token = parse
    | commment                          { token lexbuf } (* skip comments *)
    | [' ' '\t']                        { token lexbuf } (* skip blanks*)
    | '\n'                              { Lexing.new_line lexbuf ; token lexbuf }
    | '-'? digits as lxm                { INT_CONST (int_of_string lxm) }
    | '-'? floating as lxm              { FLOAT_CONST (float_of_string lxm) }
    | eof                               { EOF }
    (*  keywords *)
    | "not"                             { NOT }
    | "and"                             { AND }
    | "or"                              { OR }
    | "float"                           { FLOAT }
    | "int"                             { INT }
    | "bool"                            { BOOL }
    | "false"                           { BOOL_CONST false }
    | "true"                            { BOOL_CONST true }
    | "while"                           { WHILE }
    | "do"                              { DO }
    | "od"                              { OD }
    | "if"                              { IF }
    | "then"                            { THEN }
    | "else"                            { ELSE }
    | "fi"                              { FI }
    | "proc"                            { PROC }
    | "end"                             { END }
    | "read"                            { READ }
    | "write"                           { WRITE }
    | "ref"                             { REF }
    | "val"                             { VAL }
    | ":="                              { ASSIGN }
    | '('                               { LPAREN }
    | ')'                               { RPAREN }
    | '['                               { LSQBRACK }
    | ']'                               { RSQBRACK }
    | '='                               { EQ }
    | '.'                               { DOT }
    | "!="                              { NE }
    | ">="                              { GE }
    | "<="                              { LE }
    | '>'                               { GT }
    | '<'                               { LT }
    | '+'                               { PLUS }
    | '-'                               { MINUS }
    | '*'                               { MULTI }
    | '/'                               { DIVID }
    | ','                               { COMMA }
    | ';'                               { SEMICOLON }
    | ident as lxm                      { IDENT lxm }
    | string as lxm                     { STRING_CONST lxm}
============================================
src/Makefile.depend
18:00:06_Sunday_09_April_2017
============================================
#
# Makefile.depend
#
# Group Name: Mainframe
#

snick.cmo : snick_pprint.cmi snick_parse.cmi snick_lex.cmo
snick.cmx : snick_pprint.cmx snick_parse.cmx snick_lex.cmx
snick_ast.cmi :
snick_parse.cmi : snick_ast.cmi
snick_pprint.cmi : snick_ast.cmi
snick_ast.cmo : snick_ast.cmi
snick_ast.cmx : snick_ast.cmi
snick_lex.cmo : snick_parse.cmi
snick_lex.cmx : snick_parse.cmx
snick_parse.cmo : snick_ast.cmi snick_parse.cmi
snick_parse.cmx : snick_ast.cmx snick_parse.cmi
snick_pprint.cmo : snick_ast.cmi snick_pprint.cmi
snick_pprint.cmx : snick_ast.cmx snick_pprint.cmi
snick.cmo : snick_pprint.cmi snick_parse.cmi snick_lex.cmo
snick.cmx : snick_pprint.cmx snick_parse.cmx snick_lex.cmx
============================================
src/snick.ml
18:00:06_Sunday_09_April_2017
============================================
(*
** File:          snick.ml
** Description:   Main file for Snick compiler,
**                modified based on given sample.
** Last Modified: Sun. 9th April 2017 
** 
** Group name: Mainframe
** 
** Member names   | usernames
** Xianzhuo REN   | xianzhuor 
** Haoyu LIN      | haoyul3
** Zequn MA       | zequnm
*)

module P = Snick_parse

(* Argument parsing code *)
let infile_name = ref None

type compiler_mode = PrettyPrint | Compile
let mode = ref Compile

(* define exception type *)
exception ParsingErr of string
exception LexingErr of string

(* print current position of lexbuf *)
let err_pos lexbuf =
    let pos = Lexing.lexeme_start_p lexbuf in
        Format.sprintf ": line %d, col %d."
            (pos.Lexing.pos_lnum)
            (pos.Lexing.pos_cnum - pos.Lexing.pos_bol) 

(* --------------------------------------------- *)
(*  Specification for command-line options       *)
(* --------------------------------------------- *)
let (speclist:(Arg.key * Arg.spec * Arg.doc) list) =
    ["-p",
       Arg.Unit(fun () -> mode := PrettyPrint),
       " Run the compiler in pretty-printer mode"
    ]

let main () =
    (* Parse the command-line arguments *)
    Arg.parse speclist
        (begin fun fname -> infile_name := Some fname end)
        "snick [-p] [bean source]" ;
    (* Open the input file *)
    let infile = match !infile_name with
    | None -> stdin
    | Some fname -> open_in fname in
    (* Initialize lexing buffer *)
    let lexbuf = Lexing.from_channel infile in
    (* Call the parser *)
    try
        let prog = Snick_parse.program Snick_lex.token lexbuf in
        match !mode with
        | PrettyPrint -> Printf.printf "proc\n" (* Snick_pprint.print_program Format.std_formatter prog *)
        | Compile -> print_string "Compiling function is not yet enabled!!!\n"
    with
        (* Handle failure from lexer, print error position. *)
        | Failure x -> raise (LexingErr ("Lexing Error" ^ (err_pos lexbuf) ^ "\n"))
        (* Handle error from parser, print error position. *)
        | Parsing.Parse_error -> raise (ParsingErr ("Parsing Error" ^ (err_pos lexbuf) ^ "\n"))

let _ = main ()
============================================
src/snick_pprint.ml
18:00:06_Sunday_09_April_2017
============================================
(*
** File:          snick_pprint.ml
** Description:   Pretty-printer converts from snick source 
**                code to well-formed style.
** Last Modified: Sun. 9th April 2017
** 
** Group name: Mainframe
** 
** Member names   | usernames
** Xianzhuo REN   | xianzhuor 
** Haoyu LIN      | haoyul3
** Zequn MA       | zequnm
*)

open Snick_ast
open Format

let rec print_program fmtr prog = print_procs fmtr prog

and print_procs fmtr = function
    | [] -> ()
    | x::[] -> fprintf fmtr "%a@," print_proc x
    | x::xs -> fprintf fmtr "%a@,%a" print_proc x print_procs xs

and print_proc fmtr (header, body) =
    fprintf fmtr "@[<v>proc %a@;<0 4>@[<v>%a@]@,end@]@."
                print_proc_header header print_proc_body body

and print_proc_header fmtr (ident, params) =
    fprintf fmtr "%s (%a)" ident print_params params

and print_params fmtr = function
    | [] -> ()
    | x :: [] -> fprintf fmtr "%a" print_param x
    | x :: xs -> fprintf fmtr "%a, %a" print_param x print_params  xs

and print_param fmtr (indicator, param_type, ident) =
    fprintf fmtr "%a %a %s" print_param_indc indicator print_type param_type ident

and print_param_indc fmtr = function
    | Val -> fprintf fmtr "%s" "val"
    | Ref -> fprintf fmtr "%s" "ref"

and print_type fmtr = function
    | Bool -> fprintf fmtr "%s" "bool"
    | Int -> fprintf fmtr "%s" "int"
    | Float -> fprintf fmtr "%s" "float"

and print_proc_body fmtr prog_body =
    fprintf fmtr "%a@,%a" print_decls prog_body.decls print_stmts prog_body.stmts
    
and print_decls fmtr = function
    | [] -> ()
    | x :: [] -> fprintf fmtr "%a@," print_decl x
    | x :: xs -> fprintf fmtr "%a@,%a" print_decl x print_decls xs

and print_stmts fmtr = function
    | [] -> ()
    | x :: [] -> fprintf fmtr "%a" print_stmt x
    | x :: xs -> fprintf fmtr "%a@,%a" print_stmt x print_stmts xs

and print_decl fmtr (var_type, variable) =
    fprintf fmtr "%a %a;" print_type var_type print_var variable

and print_var fmtr = function
    | Single_variable ident -> fprintf fmtr "%s" ident
    | Array_variable (ident, itvls) -> fprintf fmtr "%s[%a]" ident print_itvls itvls

and print_itvls fmtr = function
    | [] -> ()
    | x::[] -> fprintf fmtr "%a" print_itvl x
    | x::xs -> fprintf fmtr "%a,%a" print_itvl x print_itvls xs

and print_itvl fmtr (st_pnt, end_pnt) =
    fprintf fmtr "%d..%d" st_pnt end_pnt

and print_stmt fmtr = function
    | Atom_stmt atom_stmt -> fprintf fmtr "%a" print_atom_stmt atom_stmt
    | Comps_stmt comps_stmt -> fprintf fmtr "%a" print_comps_stmt comps_stmt

and print_atom_stmt fmtr = function
    | Assign (elem, expr) -> fprintf fmtr "%a := %a;" print_elem elem print_expr expr
    | Read elem -> fprintf fmtr "read %a;" print_elem elem
    | Write expr -> fprintf fmtr "write %a;" print_expr expr
    | Call (ident, exprs) -> fprintf fmtr "%s(%a);" ident print_exprs exprs

and print_comps_stmt fmtr = function
    | If_then (expr, stmts) -> fprintf fmtr "if %a then@;<0 4>@[<v>%a@]@,fi"
                                print_expr expr print_stmts stmts
    | If_then_else (expr, then_stmts, else_stmts) ->
        fprintf fmtr "if %a then@;<0 4>@[<v>%a@]@,else@;<0 4>@[<v>%a@]@,fi"
                print_expr expr print_stmts then_stmts print_stmts else_stmts
    | While (expr, stmts) -> fprintf fmtr "while %a do@;<0 4>@[<v>%a@]@,od"
                print_expr expr print_stmts stmts

and print_elem fmtr = function
    | Single_elem ident -> fprintf fmtr "%s" ident
    | Array_elem (ident, idxs) -> fprintf fmtr "%s[%a]" ident print_exprs idxs

and print_expr fmtr = function
    | Eelem elem -> fprintf fmtr "%a" print_elem elem
    | Ebool bool_const -> fprintf fmtr "%B" bool_const
    | Eint int_const -> fprintf fmtr "%d" int_const
    | Efloat float_const -> fprintf fmtr "%f" float_const
    | Estring string_const -> fprintf fmtr "%s" string_const
    | Eparen expr -> fprintf fmtr "%a" print_expr (strip_paren expr)
    | Ebinop bin_expr -> fprintf fmtr "%a" print_binop bin_expr
    | Eunop un_expr -> fprintf fmtr "%a" print_unop un_expr

and print_exprs fmtr = function
    | [] -> ()
    | x::[] -> fprintf fmtr "%a" print_expr x
    | x::xs -> fprintf fmtr "%a, %a" print_expr x print_exprs xs

and print_binop fmtr (lexpr, binop, rexpr) = match binop with
    | Op_add -> fprintf fmtr "%a" print_add_expr (lexpr, rexpr)
    | Op_sub -> fprintf fmtr "%a" print_sub_expr (lexpr, rexpr)
    | Op_mul -> fprintf fmtr "%a" print_mul_expr (lexpr, rexpr)
    | Op_div -> fprintf fmtr "%a" print_div_expr (lexpr, rexpr)
    | Op_eq -> fprintf fmtr "%a" print_eq_expr (lexpr, rexpr)
    | Op_ne -> fprintf fmtr "%a" print_ne_expr (lexpr, rexpr)
    | Op_lt -> fprintf fmtr "%a" print_lt_expr (lexpr, rexpr)
    | Op_gt -> fprintf fmtr "%a" print_gt_expr (lexpr, rexpr)
    | Op_le -> fprintf fmtr "%a" print_le_expr (lexpr, rexpr)
    | Op_ge -> fprintf fmtr "%a" print_ge_expr (lexpr, rexpr)
    | Op_and -> fprintf fmtr "%a" print_and_expr (lexpr, rexpr)
    | Op_or -> fprintf fmtr "%a" print_or_expr (lexpr, rexpr)

and print_unop fmtr (unop, expr) = match unop with
    | Op_not -> fprintf fmtr "%a" print_not_expr expr
    | Op_minus -> fprintf fmtr "%a" print_minus_expr expr

and print_add_expr fmtr = function
    | (lexpr, Eparen rexpr_inside) ->
        begin
            let
                lexpr_strip = strip_paren lexpr 
            and
                rexpr_inside_strip = strip_paren rexpr_inside
            in
                match rexpr_inside_strip with
                | Eelem _  | Eint _ | Efloat _
                | Ebinop (_, Op_mul, _) | Ebinop (_, Op_div, _) | Eunop (Op_minus, _)
                    -> fprintf fmtr "%a + %a"
                            print_expr lexpr_strip print_expr rexpr_inside_strip
                | _ -> fprintf fmtr "%a + (%a)"
                            print_expr lexpr_strip print_expr rexpr_inside_strip
        end
    | (lexpr, rexpr) ->
        let
            lexpr_strip = strip_paren lexpr
        in
            fprintf fmtr "%a + %a" print_expr lexpr_strip print_expr rexpr

and print_sub_expr fmtr = function
    | (lexpr, Eparen rexpr_inside) ->
        begin
            let
                lexpr_strip = strip_paren lexpr 
            and
                rexpr_inside_strip = strip_paren rexpr_inside
            in
                match rexpr_inside_strip with
                | Eelem _ | Eint _ | Efloat _
                | Ebinop (_, Op_mul, _) | Ebinop (_, Op_div, _) | Eunop (Op_minus, _)
                    -> fprintf fmtr "%a - %a"
                                print_expr lexpr_strip print_expr rexpr_inside_strip
                | _ -> fprintf fmtr "%a - (%a)"
                                print_expr lexpr_strip print_expr rexpr_inside_strip
        end
    | (lexpr, rexpr) ->
        let
            lexpr_strip = strip_paren lexpr
        in
            fprintf fmtr "%a - %a" print_expr lexpr_strip print_expr rexpr

and print_mul_expr fmtr = function
    | (Eparen lexpr_inside, Eparen rexpr_inside) ->
        begin
            let
                lexpr_inside_strip = strip_paren lexpr_inside
            and
                rexpr_inside_strip = strip_paren rexpr_inside
            in
                match lexpr_inside_strip with
                | Eelem _ | Eint _ | Efloat _
                | Ebinop (_, Op_mul, _) | Ebinop (_, Op_div, _) | Eunop (Op_minus, _)
                    ->
                    begin
                        match rexpr_inside_strip with
                        | Eelem _ | Eint _ | Efloat _
                        | Eunop (Op_minus, _) -> fprintf fmtr "%a * %a"
                                        print_expr lexpr_inside_strip print_expr rexpr_inside_strip            
                        | _ -> fprintf fmtr "%a * (%a)"
                                        print_expr lexpr_inside_strip print_expr rexpr_inside_strip
                    end
                | _ ->
                    begin
                        match rexpr_inside_strip with
                        | Eelem _ | Eint _ | Efloat _
                        | Eunop (Op_minus, _) -> fprintf fmtr "(%a) * %a"
                                    print_expr lexpr_inside_strip print_expr rexpr_inside_strip            
                        | _ -> fprintf fmtr "(%a) * (%a)"
                                    print_expr lexpr_inside_strip print_expr rexpr_inside_strip
                    end
        end
    | (Eparen lexpr_inside, rexpr) ->
        begin
            let
                lexpr_inside_strip = strip_paren lexpr_inside
            in
                match lexpr_inside_strip with
                | Eelem _ | Eint _ | Efloat _
                | Ebinop (_, Op_mul, _) | Ebinop (_, Op_div, _) | Eunop (Op_minus, _)
                    -> fprintf fmtr "%a * %a"
                            print_expr lexpr_inside_strip print_expr rexpr
                | _ -> fprintf fmtr "(%a) * %a"
                            print_expr lexpr_inside_strip print_expr rexpr
        end
    | (lexpr, Eparen rexpr_inside) ->
        begin
            let
                rexpr_inside_strip = strip_paren rexpr_inside
            in
                match rexpr_inside_strip with
                | Eelem _ | Eint _ | Efloat _
                | Eunop (Op_minus, _)
                    -> fprintf fmtr "%a * %a"
                            print_expr lexpr print_expr rexpr_inside_strip            
                | _ -> fprintf fmtr "%a * (%a)"
                            print_expr lexpr print_expr rexpr_inside_strip
        end
    | (lexpr, rexpr) -> fprintf fmtr "%a * %a" print_expr lexpr print_expr rexpr

and print_div_expr fmtr = function
    | (Eparen lexpr_inside, Eparen rexpr_inside) ->
        begin
            let
                lexpr_inside_strip = strip_paren lexpr_inside
            and
                rexpr_inside_strip = strip_paren rexpr_inside
            in
                match lexpr_inside_strip with
                | Eelem _ | Eint _ | Efloat _
                | Ebinop (_, Op_mul, _) | Ebinop (_, Op_div, _) | Eunop (Op_minus, _)
                    ->
                    begin
                        match rexpr_inside_strip with
                        | Eelem _ | Eint _ | Efloat _
                        | Eunop (Op_minus, _)
                            -> fprintf fmtr "%a / %a"
                                    print_expr lexpr_inside_strip print_expr rexpr_inside_strip            
                        | _ -> fprintf fmtr "%a / (%a)"
                                    print_expr lexpr_inside_strip print_expr rexpr_inside_strip
                    end
                | _ ->
                    begin
                        match rexpr_inside_strip with
                        | Eelem _ | Eint _ | Efloat _
                        | Eunop (Op_minus, _)
                            -> fprintf fmtr "(%a) / %a"
                                    print_expr lexpr_inside_strip print_expr rexpr_inside_strip            
                        | _ -> fprintf fmtr "(%a) / (%a)"
                                    print_expr lexpr_inside_strip print_expr rexpr_inside_strip
                    end
        end
    | (Eparen lexpr_inside, rexpr) ->
        begin
            let
                lexpr_inside_strip = strip_paren lexpr_inside
            in
                match lexpr_inside_strip with
                | Eelem _ | Eint _ | Efloat _
                | Ebinop (_, Op_mul, _) | Ebinop (_, Op_div, _) | Eunop (Op_minus, _)
                    -> fprintf fmtr "%a / %a"
                            print_expr lexpr_inside_strip print_expr rexpr
                | _ -> fprintf fmtr "(%a) / %a"
                            print_expr lexpr_inside_strip print_expr rexpr
        end
    | (lexpr, Eparen rexpr_inside) ->
        begin
            let
                rexpr_inside_strip = strip_paren rexpr_inside
            in
                match rexpr_inside_strip with
                | Eelem _ | Eint _ | Efloat _
                | Eunop (Op_minus, _)
                    -> fprintf fmtr "%a / %a"
                                print_expr lexpr print_expr rexpr_inside_strip            
                | _ -> fprintf fmtr "%a / (%a)"
                                print_expr lexpr print_expr rexpr_inside_strip
        end
    | (lexpr, rexpr) -> fprintf fmtr "%a / %a" print_expr lexpr print_expr rexpr

and print_eq_expr fmtr = function
    | (Eparen lexpr_inside, Eparen rexpr_inside) ->
        begin
            let
                lexpr_inside_strip = strip_paren lexpr_inside
            and
                rexpr_inside_strip = strip_paren rexpr_inside
            in
                match lexpr_inside_strip with
                | Ebinop (_, Op_and, _) | Ebinop (_, Op_or, _) | Eunop (Op_not, _)
                    ->
                    begin
                        match rexpr_inside_strip with
                        | Eelem _ | Eint _ | Efloat _
                        | Ebinop (_, Op_add, _) | Ebinop (_, Op_sub, _)
                        | Ebinop (_, Op_mul, _) | Ebinop (_, Op_div, _)
                        | Eunop (Op_minus, _)
                            -> fprintf fmtr "(%a) = %a"
                                        print_expr lexpr_inside_strip print_expr rexpr_inside_strip            
                        | _ -> fprintf fmtr "(%a) = (%a)"
                                        print_expr lexpr_inside_strip print_expr rexpr_inside_strip
                    end
                | _ ->
                    begin
                        match rexpr_inside_strip with
                        | Eelem _ | Ebool _ | Eint _ | Efloat _
                        | Ebinop (_, Op_add, _) | Ebinop (_, Op_sub, _)
                        | Ebinop (_, Op_mul, _) | Ebinop (_, Op_div, _)
                        | Eunop (Op_minus, _)
                            -> fprintf fmtr "%a = %a"
                                        print_expr lexpr_inside_strip print_expr rexpr_inside_strip            
                        | _ -> fprintf fmtr "%a = (%a)"
                                        print_expr lexpr_inside_strip print_expr rexpr_inside_strip
                    end
        end
    | (Eparen lexpr_inside, rexpr) ->
        begin
            let
                lexpr_inside_strip = strip_paren lexpr_inside
            in
                match lexpr_inside_strip with
                | Ebinop (_, Op_or, _) | Ebinop (_, Op_and, _) | Eunop (Op_not, _)
                    -> fprintf fmtr "(%a) = %a"
                                print_expr lexpr_inside_strip print_expr rexpr
                | _ -> fprintf fmtr "%a = %a"
                                print_expr lexpr_inside_strip print_expr rexpr
        end
    | (lexpr, Eparen rexpr_inside) ->
        begin
            let
                rexpr_inside_strip = strip_paren rexpr_inside
            in
                match rexpr_inside_strip with
                | Eelem _ | Ebool _ | Eint _ | Efloat _
                | Ebinop (_, Op_add, _) | Ebinop (_, Op_sub, _)
                | Ebinop (_, Op_mul, _) | Ebinop (_, Op_div, _)
                | Eunop (Op_minus, _)
                    -> fprintf fmtr "%a = %a"
                                print_expr lexpr print_expr rexpr_inside_strip            
                | _ -> fprintf fmtr "%a = (%a)"
                                print_expr lexpr print_expr rexpr_inside_strip
        end
    | (lexpr, rexpr) -> fprintf fmtr "%a = %a" print_expr lexpr print_expr rexpr

and print_ne_expr fmtr = function
    | (Eparen lexpr_inside, Eparen rexpr_inside) ->
        begin
            let
                lexpr_inside_strip = strip_paren lexpr_inside
            and
                rexpr_inside_strip = strip_paren rexpr_inside
            in
                match lexpr_inside_strip with
                | Ebinop (_, Op_and, _) | Ebinop (_, Op_or, _) | Eunop (Op_not, _)
                    ->
                    begin
                        match rexpr_inside_strip with
                        | Eelem _ | Ebool _ | Eint _ | Efloat _
                        | Ebinop (_, Op_add, _) | Ebinop (_, Op_sub, _)
                        | Ebinop (_, Op_mul, _) | Ebinop (_, Op_div, _)
                        | Eunop (Op_minus, _)
                            -> fprintf fmtr "(%a) != %a"
                                    print_expr lexpr_inside_strip print_expr rexpr_inside_strip            
                        | _ -> fprintf fmtr "(%a) != (%a)"
                                    print_expr lexpr_inside_strip print_expr rexpr_inside_strip
                    end
                | _ ->
                    begin
                        match rexpr_inside_strip with
                        | Eelem _ | Ebool _ | Eint _ | Efloat _
                        | Ebinop (_, Op_add, _) | Ebinop (_, Op_sub, _)
                        | Ebinop (_, Op_mul, _) | Ebinop (_, Op_div, _)
                        | Eunop (Op_minus, _)
                            -> fprintf fmtr "%a != %a"
                                    print_expr lexpr_inside_strip print_expr rexpr_inside_strip            
                        | _ -> fprintf fmtr "%a != (%a)"
                                    print_expr lexpr_inside_strip print_expr rexpr_inside_strip
                    end
        end
    | (Eparen lexpr_inside, rexpr) ->
        begin
            let
                lexpr_inside_strip = strip_paren lexpr_inside
            in
                match lexpr_inside_strip with
                | Ebinop (_, Op_or, _)
                | Ebinop (_, Op_and, _)
                | Eunop (Op_not, _) -> fprintf fmtr "(%a) != %a" 
                    print_expr lexpr_inside_strip print_expr rexpr
                | _ -> fprintf fmtr "%a != %a" 
                    print_expr lexpr_inside_strip print_expr rexpr
        end
    | (lexpr, Eparen rexpr_inside) ->
        begin
            let
                rexpr_inside_strip = strip_paren rexpr_inside
            in
                match rexpr_inside_strip with
                | Eelem _ | Ebool _ | Eint _ | Efloat _
                | Ebinop (_, Op_add, _) | Ebinop (_, Op_sub, _)
                | Ebinop (_, Op_mul, _) | Ebinop (_, Op_div, _)
                | Eunop (Op_minus, _)
                    -> fprintf fmtr "%a != %a" print_expr lexpr print_expr rexpr_inside_strip            
                | _ -> fprintf fmtr "%a != (%a)" print_expr lexpr print_expr rexpr_inside_strip
        end
    | (lexpr, rexpr) -> fprintf fmtr "%a != %a" print_expr lexpr print_expr rexpr

and print_lt_expr fmtr (lexpr, rexpr) = 
        let
            lexpr_strip = strip_paren lexpr
        and
            rexpr_strip = strip_paren rexpr
        in
            fprintf fmtr "%a < %a" print_expr lexpr_strip print_expr rexpr_strip


and print_gt_expr fmtr (lexpr, rexpr) = 
        let
            lexpr_strip = strip_paren lexpr
        and
            rexpr_strip = strip_paren rexpr
        in
            fprintf fmtr "%a > %a" print_expr lexpr_strip print_expr rexpr_strip

and print_le_expr fmtr (lexpr, rexpr) = 
        let
            lexpr_strip = strip_paren lexpr
        and
            rexpr_strip = strip_paren rexpr
        in
            fprintf fmtr "%a <= %a" print_expr lexpr_strip print_expr rexpr_strip

and print_ge_expr fmtr (lexpr, rexpr) = 
        let
            lexpr_strip = strip_paren lexpr
        and
            rexpr_strip = strip_paren rexpr
        in
            fprintf fmtr "%a >= %a" print_expr lexpr_strip print_expr rexpr_strip

and print_and_expr fmtr = function
    | (Eparen lexpr_inside, Eparen rexpr_inside) ->
        begin
            let
               lexpr_inside_strip = strip_paren lexpr_inside
            and
                rexpr_inside_strip = strip_paren rexpr_inside
            in
                match lexpr_inside_strip with
                | Ebinop (_, Op_or, _) ->
                    begin
                        match rexpr_inside_strip with
                        | Ebinop (_, Op_and, _) | Ebinop (_, Op_or, _)
                            -> fprintf fmtr "(%a) and (%a)"
                                        print_expr lexpr_inside_strip print_expr rexpr_inside_strip
                        | _ -> fprintf fmtr "(%a) and %a"
                                        print_expr lexpr_inside_strip print_expr rexpr_inside_strip
                    end
                | _ ->
                    begin
                        match rexpr_inside_strip with
                        | Ebinop (_, Op_and, _) | Ebinop (_, Op_or, _)
                            -> fprintf fmtr "%a and (%a)"
                                        print_expr lexpr_inside_strip print_expr rexpr_inside_strip
                        | _ -> fprintf fmtr "%a and %a"
                                        print_expr lexpr_inside_strip print_expr rexpr_inside_strip
                    end
        end
    | (Eparen lexpr_inside, rexpr) ->
        begin
            let
               lexpr_inside_strip = strip_paren lexpr_inside
            in
                match lexpr_inside_strip with
                | Ebinop (_, Op_or, _) -> fprintf fmtr "(%a) and %a"
                                print_expr lexpr_inside_strip print_expr rexpr
                | _ -> fprintf fmtr "%a and %a"
                                print_expr lexpr_inside_strip print_expr rexpr
        end
    | (lexpr, Eparen rexpr_inside) ->
        begin
            let
                rexpr_inside_strip = strip_paren rexpr_inside
            in
                match rexpr_inside_strip with
                | Ebinop (_, Op_and, _) | Ebinop (_, Op_or, _)
                    -> fprintf fmtr "%a and (%a)" print_expr lexpr print_expr rexpr_inside_strip
                | _ -> fprintf fmtr "%a and %a" print_expr lexpr print_expr rexpr_inside_strip
        end
    | (lexpr, rexpr) -> fprintf fmtr "%a and %a" print_expr lexpr print_expr rexpr

and print_or_expr fmtr = function
    | (lexpr, Eparen rexpr_inside) ->
        begin
            let
                lexpr_strip = strip_paren lexpr
            and
                rexpr_inside_strip = strip_paren rexpr_inside
            in
                match rexpr_inside_strip with
                | Ebinop (_, Op_or, _) -> fprintf fmtr "%a or (%a)"
                                print_expr lexpr_strip print_expr rexpr_inside_strip
                | _ -> fprintf fmtr "%a or %a"
                                print_expr lexpr_strip print_expr rexpr_inside_strip
        end
    | (lexpr, rexpr) -> 
        let
            lexpr_strip = strip_paren lexpr
        in
            fprintf fmtr "%a or %a" print_expr lexpr_strip print_expr rexpr

and print_not_expr fmtr = function
    | Eparen expr_inside ->
        begin
            let
                expr_inside_strip = strip_paren expr_inside
            in
                match expr_inside_strip with
                | Ebinop (_, Op_and, _) | Ebinop (_, Op_or, _)
                    -> fprintf fmtr "%s (%a)" "not"
                                print_expr expr_inside_strip
                | _ -> fprintf fmtr "%s %a" "not"
                                print_expr expr_inside_strip
        end
    | expr -> fprintf fmtr "%s %a" "not" print_expr expr

and print_minus_expr fmtr = function
    | Eparen expr_inside ->
        begin
            let
                expr_inside_strip = strip_paren expr_inside
            in
                match expr_inside_strip with
                | Eelem _  | Eint _ | Efloat _
                | Eunop (Op_minus, _)
                    -> fprintf fmtr "%s %a" "-"
                            print_expr expr_inside_strip
                | _ -> fprintf fmtr "%s (%a)" "-"
                            print_expr expr_inside_strip
        end
    | expr -> fprintf fmtr "%s %a" "-" print_expr expr

and strip_paren expr = match expr with
    | Eparen paren_expr -> strip_paren paren_expr
    | _ -> expr
============================================
src/snick_ast.ml
18:00:06_Sunday_09_April_2017
============================================
(*
** File:          snick_ast.ml
** Description:   Specification of the abstract syntax tree for Snick
** Last Modified: Sun. 9th April 2017
** 
** Group name: Mainframe
** 
** Member names   | usernames
** Xianzhuo REN   | xianzhuor 
** Haoyu LIN      | haoyul3
** Zequn MA       | zequnm
*)

(* identifier *)
type ident = string

(* primitive types *)
type snicktype =
    | Bool
    | Int
    | Float 

(* array dimensions *)
type interval = (int * int)

(* variable representations *)
type variable =
    | Single_variable of ident
    | Array_variable of (ident * interval list)

(* single declation *)
type decl = (snicktype * variable)

(* binary operators *)
type binop =
    | Op_add | Op_sub | Op_mul | Op_div
    | Op_eq | Op_ne | Op_lt | Op_gt | Op_le | Op_ge
    | Op_and | Op_or

(* unary operators *)
type unop =
    | Op_not
    | Op_minus

(* expression *)
type expr =
    (* variable element expression*)
    | Eelem of elem
    (* constant expression *)
    | Ebool of bool
    | Eint of int
    | Efloat of float
    | Estring of string
    (* expression inside a pair of parentheses *)
    | Eparen of expr
    (* operation expression *)
    | Ebinop of (expr * binop * expr)
    | Eunop of (unop * expr)
(* element to read, write or assign *)
and elem =
    | Single_elem of ident
    | Array_elem of (ident * expr list)

(* statement *)
type stmt =
    | Atom_stmt of atom_stmt
    | Comps_stmt of comps_stmt
and atom_stmt = (* atomic statement *)
    | Assign of (elem * expr)
    | Read of elem
    | Write of expr
    | Call of (ident * expr list)
and comps_stmt = (* composite statement *)
    | If_then of (expr * stmt list)
    | If_then_else of (expr * stmt list * stmt list)
    | While of (expr * stmt list)

(* procedure body *)
type proc_body = {
  decls : decl list ;
  stmts : stmt list
}

(* parameter indicator *)
type param_indc =
    | Val
    | Ref

(* procedure parameter *)
type param = (param_indc * snicktype * ident)

(* procedure header *)
type proc_header = (ident * param list)

(* procedure *)
type proc = (proc_header * proc_body)

(* list of procedures *)
type procs = proc list

(* program is a list of procedures *)
type program = procs

(* root node of the ast *)
type t = program