{ open Snick_parse
 exception LexFail
}

let digit = ['0'-'9']
let digits = digit+
let space = [' ' '\t']
let underline = '_'
let apostrophe = '''
let string_val = '"' [^ '"' '\t' '\n' '\r' ]* '"'
let comment = '#'[^'\n']*
let identifier =  (alpha|underline)(alpha|underline|apostrophe)*
let int_value = '-'?digits
let float_value = '-'?['1'-'9']digits'.'digits

rule token = parse

  space             { token lexbuf}
| newline           {lexing.new_line lexbuf;token lexbuf}

|int_value as lxm   {INT_VAL(int_of_string (lxm))}
|floate_value as lxm{FLOAT_VAL(float_of_string (lxm))}
|string_val as lxm  {STRING_VAL(lxm)}
| "true"            {BOOL_VAL true}
| "false"           {BOOL_VAL false}

| "proc"            {PROC}
| "end"             {END}
| "val"             {VAL}
| "ref"             {REF}
| "while"           {WHILE}
| "do"              {DO}
| "od"              {OD}
| "if"              {IF}
| "then"            {THEN}
| "else"            {ELSE}
| "fi"              {FI} 
| "bool"            {BOOL}
| "int"             {INT}
| "read"            {READ}
| "write"           {WRITE}
| "and"             {AND}
| "or"              {OR}
| "not"             {NOT}

| ':'               {COLON}
| ';'               {SEMICOLON}
| ','               {COMMA}
| '.'               {DOT}
| '('               {LP}
| ')'               {RP}
| '['               {LSP}
| ']'               {RSP}
| ":="              {EQ_COLON}
| "!="              {NE}
| '<'               {LT}
| '>'               {GT}
| "<="              {LE}
| ">="              {GE}
| '='               {EQ}
| '+'               {PLUS}
| '-'               {MINUS}
| '*'               {MUL}
| '/'               {DIV}

|identifier as lxm {IDENTIFIER(lxm)}
|commet {token lexbif}
|eof {EOF}
|_ {raise LexFail}