%{
open Snack_ast
%}


%token <bool> BOOL_VAL
%token <int> INT_VAL
%token <string> STRING_VAL

%token WRITE READ
%token ASSIGN
%token WHILE DO OD
%token IF THEN ELSE FI
%token BOOL INT
%token PROC
%token END
%token VAL
%token REF

%token EQ NE LT LE GT GE
%token PLUS MINUS MUL DIV
%token UMINUS
%token AND OR NOT
%token EQ_COLON

%token COLON
%token SEMICOLON
%token DOT
%token COMMA
%token LP RP
%token LSP RSP

%token EOF
%token <string> IDENTIFIER


%left OR
%left AND
%nonassoc NOT
%nonassoc EQ NE LT LE GT GE
%left PLUS MINUS
%left MUL DIV
%right EQ_COLON
%nonassoc UMINUS

%type <Snack_ast.program> start_state

%start start_state
%%

start_state:
| type_definition procedure_definition {{typedefs = List.rev $1;funcdefs = List.rev $2}}

type_def:
| type_spec INDENTIFIER {($1,$2)}

type_defs:
| type_defs type_def {$2::$1}
| {[]}

type_spec:
| primitive_type {$1}

primitive_type:
| BOOL {SingleTypeTerm(Bool)}
| INT {SingleTypeTerm(Int)}
| FLOAT {SingleTypeTerm(Float)}

declaration:
| type_spec IDENTIFIER SEMICOLON {SingleTypeTermWithIdent($1,$2)}

declarations:
| declarations declaration {$2::$1}
| {[]}

atomic_statement:
| left_val EQ_COLON right_val {Assign($1,$3)}
| READ left_val {Read($2)}
| WRITE expr {Write($2)}
| IDENTIFIER LP expr_list RP {Method($1,List.rev $3)}

compound_statement:
| IF expr THEN statements else_block FI {IfDec($2,List.rev $4,$5)}
| WHILE expr DO statements OD {WhileDec($2,List.rev $4)}

else_block:
| ELSE statement_list {List.rev $2}
| {[]}

statement:
| atomic_statement SEMICOLON {$1}
| compound_statement {$1}

statements:
| statements statement{$2::$1}
| statement {$1::[]}

left_val:
| IDENTIFIER {LId($1)}

right_val:
| expr { Rexpr($1) }

expr:
| left_val { Elval($1) }
| const { $1 }
| LP expr RP {Ebracket($2)}
| expr PLUS expr {Ebinop($1,Op_add,$3)}
| expr MINUS expr {Ebinop($1,Op_sub,$3)}
| expr MUL expr {Ebinop($1,Op_mul,$3)}
| expr DIV expr {Ebinop($1,Op_div,$3)}
| expr EQ expr {Ebinop($1,Op_eq,$3)}
| expr NE expr {Ebinop($1,Op_neq,$3)}
| expr LT expr {Ebinop($1,Op_lt,$3)}
| expr GT expr {Ebinop($1,Op_gt,$3)}
| expr LE expr {Ebinop($1,Op_lte,$3)}
| expr GE expr {Ebinop($1,Op_gte,$3)}
| expr AND expr {Ebinop($1,Op_and,$3)}
| expr OR expr {Ebinop($1,Op_or,$3)}
| NOT expr {Eunop(Op_not,$2)}
| MINUS expr %prec UMINUS {Eunop(Op_minus,$2)} 

expr_list:
| exprs {$1}
| {[]}

exprs:
| exprs COMMA expr {$3::$1}
| expr {$1::[]}

const:
| BOOL_VAL {Ebool($1)}
| INT_VAL {Eint($1)}
| FLOAT_VAL {Efloat($1)}
| STRING_VAL {Eident($1)}


procedure_def:
| PROC procedure_header declarations statements END {($2,List.rev $3,List.rev $4)::[]}

procedure_defs:
| procedure_defs procedure_def {($2::$1}

procedure_header:
| IDENTIFIER LP params RP {($1,List.rev $3)}

param:
| param COMMA pass_type type_spec IDENTIFIER {($3,$4,$5)::$1}
| pass_type type_spec IDENTIFIER {($1,$2,$3)::[]}

params:
| param {$1}
| {[]}

pass_type:
| VAL {Val}
| REF {Ref}



